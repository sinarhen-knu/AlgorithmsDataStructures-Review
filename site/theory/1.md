# Теоретичне завдання до лабораторної роботи №1

## Завдання
1. Розглянемо сортування елементів масиву А, яке виконується таким чином. Спочатку визначається найменший елемент масиву А, який ставиться місце елемента А[1]. Потім виконується пошук другого найменшого елемента масиву А, який ставиться на місце елемента А[2]. Цей процес продовжується для перших n-1 елементів масиву А. 
   - Запишіть псевдокод цього алгоритму, відомого як сортування вибором. Який інваріант циклу зберігається для цього алгоритму? Чому його достатньо виконати для перших n-1 елементів, а не для всіх n елементів? Визначте час роботи алгоритму у найкращому та найгіршому випадку.
2. Знайдіть рішення для таких рекурентних відносин:
а) х(n) = х(n-1) + 5, для n> 1, х (1) = 0
б) х(n) = 3x (n-1), для n> 1, х (1) = 4
в) х(n) = х(n-1) – 1+n, для п> 0, х (0) = 0
3. Розглянемо алгоритм лінійного пошуку. Для скількох елементів вхідної послідовності в середньому потрібно провести перевірку, якщо передбачається, що всі елементи масиву з рівною ймовірністю можуть мати потрібне значення? Що відбувається у найгіршому випадку? Чому дорівнює час роботи алгоритму лінійного пошуку в середньому та в найгіршому випадку? Обґрунтуйте свою відповідь.


## Відповіді
1. Сортування вибором працює наступним чином:

   Псевдокод:
    ```
    for i from 0 to n-2
        min_index = i
        for j from i+1 to n-1
            if A[j] < A[min_index]
                min_index = j
        swap A[i] and A[min_index]
    ```
   Інваріант циклу: на кожному кроці циклу, перші `i` елементів масиву є відсортованими і не більшими за всі інші елементи.

   Цього достатньо виконати для перших `n-1` елементів, оскільки після цього всі елементи, крім останнього, будуть відсортовані, а останній елемент буде вже на своєму місці, оскільки він є найбільшим.

   Час роботи алгоритму у найкращому та найгіршому випадку становить `O(n^2)`, оскільки ми виконуємо `n-1` проходів, і для кожного проходу ми виконуємо до `n` порівнянь.

2. Рішення рекурентних відносин:

   - х(n) = х(n-1) + 5, для n> 1, х (1) = 0 
     - Рішення: х(n) = 5*(n-1)

   - х(n) = 3x (n-1), для n> 1, х (1) = 4
     - Рішення: х(n) = 4*3^(n-1)

   - х(n) = х(n-1) – 1+n, для п> 0, х (0) = 0
     - Рішення: х(n) = n*(n+1)/2 - n = n^2/2 - n/2

3. Алгоритм лінійного пошуку:

У середньому, якщо всі елементи масиву з рівною ймовірністю можуть мати потрібне значення, потрібно провести перевірку для n/2 елементів. Це тому, що у середньому шуканий елемент знаходиться в середині масиву.  
У найгіршому випадку, коли шуканий елемент відсутній або знаходиться в кінці масиву, потрібно буде перевірити всі n елементів.